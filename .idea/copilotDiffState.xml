<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/course_scheduler/app/reporting/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/course_scheduler/app/reporting/__init__.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Reporting package initialization.&#10;&quot;&quot;&quot;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Reporting package initialization.&#10;&quot;&quot;&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/course_scheduler/tools/parsing_report.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/course_scheduler/tools/parsing_report.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Diagnostic tool for analyzing schedule parsing.&#10;&#10;This script generates a report on how schedule strings are parsed,&#10;helping identify and fix parsing issues.&#10;&quot;&quot;&quot;&#10;import argparse&#10;import csv&#10;import logging&#10;import os&#10;import sys&#10;from typing import List, Dict, Any&#10;&#10;# Add the parent directory to path so we can import from the app&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))&#10;&#10;from course_scheduler.app.data.excel_loader import process_excel&#10;from course_scheduler.app.utils.schedule_utils import parse_schedule&#10;&#10;&#10;def generate_parsing_report(courses: List[Any]) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;&#10;    Generate a detailed report on how schedule strings are parsed.&#10;    &#10;    Args:&#10;        courses: List of course objects&#10;        &#10;    Returns:&#10;        List of dictionaries containing parsing report data&#10;    &quot;&quot;&quot;&#10;    report = []&#10;    &#10;    for course in courses:&#10;        raw_schedule = getattr(course, 'raw_schedule', 'N/A')&#10;        parsed_schedule = getattr(course, 'schedule', [])&#10;        &#10;        report.append({&#10;            'code': course.code,&#10;            'name': course.name,&#10;            'raw_schedule': raw_schedule,&#10;            'parsed_schedule': str(parsed_schedule),&#10;            'slot_count': len(parsed_schedule),&#10;            'course_type': course.course_type,&#10;            'teacher': course.teacher&#10;        })&#10;    &#10;    return report&#10;&#10;&#10;def setup_logging():&#10;    &quot;&quot;&quot;Configure logging for the diagnostic tool.&quot;&quot;&quot;&#10;    logging.basicConfig(&#10;        level=logging.INFO,&#10;        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',&#10;        handlers=[&#10;            logging.StreamHandler(),&#10;            logging.FileHandler('parsing_diagnostic.log')&#10;        ]&#10;    )&#10;&#10;&#10;def create_parsing_report(excel_file: str, sheet_name: str, output_file: str):&#10;    &quot;&quot;&quot;&#10;    Create a CSV report detailing how each course's schedule was parsed.&#10;&#10;    Args:&#10;        excel_file: Path to the Excel file with course data&#10;        sheet_name: Name of the Excel sheet to process&#10;        output_file: Path to save the CSV report&#10;    &quot;&quot;&quot;&#10;    logger = logging.getLogger(&quot;parsing_report&quot;)&#10;    logger.info(f&quot;Processing Excel file: {excel_file}, sheet: {sheet_name}&quot;)&#10;&#10;    try:&#10;        # Load courses from Excel&#10;        courses = process_excel(excel_file, sheet_name)&#10;        logger.info(f&quot;Successfully loaded {len(courses)} courses&quot;)&#10;&#10;        # Generate parsing report&#10;        report = generate_parsing_report(courses)&#10;        logger.info(f&quot;Generated parsing report for {len(report)} courses&quot;)&#10;&#10;        # Count courses with empty schedules&#10;        empty_schedules = [item for item in report if item['slot_count'] == 0]&#10;        logger.info(f&quot;Found {len(empty_schedules)} courses with empty schedules&quot;)&#10;&#10;        # Write report to CSV&#10;        with open(output_file, 'w', newline='', encoding='utf-8') as f:&#10;            if not report:&#10;                logger.error(&quot;No data to write to report&quot;)&#10;                return&#10;&#10;            fieldnames = report[0].keys()&#10;            writer = csv.DictWriter(f, fieldnames=fieldnames)&#10;            writer.writeheader()&#10;&#10;            for item in report:&#10;                writer.writerow(item)&#10;&#10;        logger.info(f&quot;Report written to {output_file}&quot;)&#10;&#10;        # Print summary to console&#10;        print(f&quot;\nParsing Report Summary:&quot;)&#10;        print(f&quot;Total courses: {len(courses)}&quot;)&#10;        print(f&quot;Courses with empty schedules: {len(empty_schedules)}&quot;)&#10;&#10;        # Print details of courses with empty schedules&#10;        if empty_schedules:&#10;            print(&quot;\nCourses with empty schedules:&quot;)&#10;            for item in empty_schedules:&#10;                print(f&quot;  - {item['code']}: Raw schedule = '{item['raw_schedule']}'&quot;)&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error creating parsing report: {e}&quot;, exc_info=True)&#10;        raise&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point for the parsing report tool.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Generate a report on schedule parsing&quot;)&#10;    parser.add_argument(&quot;excel_file&quot;, help=&quot;Path to Excel file with course data&quot;)&#10;    parser.add_argument(&quot;--sheet&quot;, &quot;-s&quot;, default=&quot;Sheet1&quot;, help=&quot;Excel sheet name (default: Sheet1)&quot;)&#10;    parser.add_argument(&quot;--output&quot;, &quot;-o&quot;, default=&quot;parsing_report.csv&quot;, help=&quot;Output CSV file (default: parsing_report.csv)&quot;)&#10;&#10;    args = parser.parse_args()&#10;    setup_logging()&#10;&#10;    create_parsing_report(args.excel_file, args.sheet, args.output)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Diagnostic tool for analyzing schedule parsing.&#10;&#10;This script generates a report on how schedule strings are parsed,&#10;helping identify and fix parsing issues.&#10;&quot;&quot;&quot;&#10;import argparse&#10;import csv&#10;import logging&#10;import os&#10;import sys&#10;from typing import List, Dict, Any&#10;&#10;# Add the parent directory to path so we can import from the app&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))&#10;&#10;from course_scheduler.app.data.excel_loader import process_excel&#10;from course_scheduler.app.utils.schedule_utils import parse_schedule&#10;&#10;&#10;def generate_parsing_report(courses: List[Any]) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;&#10;    Generate a detailed report on how schedule strings are parsed.&#10;    &#10;    Args:&#10;        courses: List of course objects&#10;        &#10;    Returns:&#10;        List of dictionaries containing parsing report data&#10;    &quot;&quot;&quot;&#10;    report = []&#10;    &#10;    for course in courses:&#10;        raw_schedule = getattr(course, 'raw_schedule', 'N/A')&#10;        parsed_schedule = getattr(course, 'schedule', [])&#10;        &#10;        report.append({&#10;            'code': course.code,&#10;            'name': course.name,&#10;            'raw_schedule': raw_schedule,&#10;            'parsed_schedule': str(parsed_schedule),&#10;            'slot_count': len(parsed_schedule),&#10;            'course_type': course.course_type,&#10;            'teacher': course.teacher&#10;        })&#10;    &#10;    return report&#10;&#10;&#10;def setup_logging():&#10;    &quot;&quot;&quot;Configure logging for the diagnostic tool.&quot;&quot;&quot;&#10;    logging.basicConfig(&#10;        level=logging.INFO,&#10;        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',&#10;        handlers=[&#10;            logging.StreamHandler(),&#10;            logging.FileHandler('parsing_diagnostic.log')&#10;        ]&#10;    )&#10;&#10;&#10;def create_parsing_report(excel_file: str, sheet_name: str, output_file: str):&#10;    &quot;&quot;&quot;&#10;    Create a CSV report detailing how each course's schedule was parsed.&#10;&#10;    Args:&#10;        excel_file: Path to the Excel file with course data&#10;        sheet_name: Name of the Excel sheet to process&#10;        output_file: Path to save the CSV report&#10;    &quot;&quot;&quot;&#10;    logger = logging.getLogger(&quot;parsing_report&quot;)&#10;    logger.info(f&quot;Processing Excel file: {excel_file}, sheet: {sheet_name}&quot;)&#10;&#10;    try:&#10;        # Load courses from Excel&#10;        courses = process_excel(excel_file, sheet_name)&#10;        logger.info(f&quot;Successfully loaded {len(courses)} courses&quot;)&#10;&#10;        # Generate parsing report&#10;        report = generate_parsing_report(courses)&#10;        logger.info(f&quot;Generated parsing report for {len(report)} courses&quot;)&#10;&#10;        # Count courses with empty schedules&#10;        empty_schedules = [item for item in report if item['slot_count'] == 0]&#10;        logger.info(f&quot;Found {len(empty_schedules)} courses with empty schedules&quot;)&#10;&#10;        # Write report to CSV&#10;        with open(output_file, 'w', newline='', encoding='utf-8') as f:&#10;            if not report:&#10;                logger.error(&quot;No data to write to report&quot;)&#10;                return&#10;&#10;            fieldnames = report[0].keys()&#10;            writer = csv.DictWriter(f, fieldnames=fieldnames)&#10;            writer.writeheader()&#10;&#10;            for item in report:&#10;                writer.writerow(item)&#10;&#10;        logger.info(f&quot;Report written to {output_file}&quot;)&#10;&#10;        # Print summary to console&#10;        print(f&quot;\nParsing Report Summary:&quot;)&#10;        print(f&quot;Total courses: {len(courses)}&quot;)&#10;        print(f&quot;Courses with empty schedules: {len(empty_schedules)}&quot;)&#10;&#10;        # Print details of courses with empty schedules&#10;        if empty_schedules:&#10;            print(&quot;\nCourses with empty schedules:&quot;)&#10;            for item in empty_schedules:&#10;                print(f&quot;  - {item['code']}: Raw schedule = '{item['raw_schedule']}'&quot;)&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error creating parsing report: {e}&quot;, exc_info=True)&#10;        raise&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point for the parsing report tool.&quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser(description=&quot;Generate a report on schedule parsing&quot;)&#10;    parser.add_argument(&quot;excel_file&quot;, help=&quot;Path to Excel file with course data&quot;)&#10;    parser.add_argument(&quot;--sheet&quot;, &quot;-s&quot;, default=&quot;Sheet1&quot;, help=&quot;Excel sheet name (default: Sheet1)&quot;)&#10;    parser.add_argument(&quot;--output&quot;, &quot;-o&quot;, default=&quot;parsing_report.csv&quot;, help=&quot;Output CSV file (default: parsing_report.csv)&quot;)&#10;&#10;    args = parser.parse_args()&#10;    setup_logging()&#10;&#10;    create_parsing_report(args.excel_file, args.sheet, args.output)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>